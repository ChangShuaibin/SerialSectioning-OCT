// Created by Microsoft (R) C/C++ Compiler Version 14.00.23918.0 (86b63e08).
//
// c:\users\nkemp\documents\visual studio 2015\projects\axsunoctcontrolconsoleapplicationproject\axsunoctcontrolconsoleapplicationproject\debug\axsunoctcontrol.tli
//
// Wrapper implementations for Win32 type library C:\Users\nkemp\Documents\OCT Host and Firmware\OCT Host and Firmware V1.15.21\AxsunOCTControl.tlb
// compiler-generated file created 10/26/16 at 11:57:09 - DO NOT EDIT!

#pragma once

//
// interface IAxsunOCTControl wrapper method implementations
//

inline unsigned long IAxsunOCTControl::StartScan ( ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_StartScan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::StopScan ( ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_StopScan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::SourceCurrentOn ( ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_SourceCurrentOn(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::SourceCurrentOff ( ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_SourceCurrentOff(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long IAxsunOCTControl::GetNumberOfOCTDevicesPresent ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetNumberOfOCTDevicesPresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IAxsunOCTControl::ConnectToOCTDevice ( long DeviceNum ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ConnectToOCTDevice(DeviceNum, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IAxsunOCTControl::ScanForOCTDevices ( ) {
    HRESULT _hr = raw_ScanForOCTDevices();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline unsigned long IAxsunOCTControl::GetFirmwareVersion ( BSTR * FirmwareVersion ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetFirmwareVersion(FirmwareVersion, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetSerialNum ( BSTR * SerialNum ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetSerialNum(SerialNum, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetSystemStatus ( SAFEARRAY * * StatusArray, unsigned long * StatusWordsReturned ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetSystemStatus(StatusArray, StatusWordsReturned, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::FPGAADCEnable ( VARIANT_BOOL Enable ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_FPGAADCEnable(Enable, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetSystemType ( unsigned long * SystemType, BSTR * SystemTypeString ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetSystemType(SystemType, SystemTypeString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::SetClockDelay ( unsigned long Delay ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_SetClockDelay(Delay, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetClockDelay ( unsigned long * Delay ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetClockDelay(Delay, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetLowSpeedAD ( SAFEARRAY * * RawVals, SAFEARRAY * * ScaledVals, SAFEARRAY * * FieldNames, unsigned long * ChannelsReturned ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetLowSpeedAD(RawVals, ScaledVals, FieldNames, ChannelsReturned, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::ReadLowSpeedAD ( unsigned long * ChannelsReturned ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_ReadLowSpeedAD(ChannelsReturned, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IAxsunOCTControl::GetLowSpeedADOneChannel ( unsigned long Channel, unsigned long * RawVal, float * ScaledVal, BSTR * FieldName ) {
    HRESULT _hr = raw_GetLowSpeedADOneChannel(Channel, RawVal, ScaledVal, FieldName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline unsigned long IAxsunOCTControl::ReadFPGARegisters ( unsigned long * RegisteresReturned ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_ReadFPGARegisters(RegisteresReturned, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IAxsunOCTControl::GetOneFPGARegister ( unsigned long RegNum, unsigned long * RegVal ) {
    HRESULT _hr = raw_GetOneFPGARegister(RegNum, RegVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT IAxsunOCTControl::GetOneFPGARegisterName ( unsigned long RegNum, BSTR * RegName ) {
    HRESULT _hr = raw_GetOneFPGARegisterName(RegNum, RegName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline unsigned long IAxsunOCTControl::SetFPGARegister ( unsigned long RegNum, unsigned long RegVal ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_SetFPGARegister(RegNum, RegVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetFPGARegister ( unsigned long RegNum, unsigned short * RegVal ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetFPGARegister(RegNum, RegVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::SendFPGAData ( SAFEARRAY * FPGAData, long nWords, unsigned long Location, unsigned long StartAddr ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_SendFPGAData(FPGAData, nWords, Location, StartAddr, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::ReadSystemStatus ( unsigned long * StatusWordsReturned ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_ReadSystemStatus(StatusWordsReturned, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IAxsunOCTControl::GetOneSystemStatus ( unsigned long StatusIndex, unsigned long * StatusValue ) {
    HRESULT _hr = raw_GetOneSystemStatus(StatusIndex, StatusValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline unsigned long IAxsunOCTControl::GetTECStatus ( unsigned long * LaserTECState, unsigned long * CountsInRange, unsigned long * CountsWarmingUp, unsigned long * CountsOutOfRange, unsigned long * TECError, unsigned long * TECTemp, unsigned long * PointsReturned, SAFEARRAY * * TECTemps, SAFEARRAY * * TECTimes, SAFEARRAY * * TECStates ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetTECStatus(LaserTECState, CountsInRange, CountsWarmingUp, CountsOutOfRange, TECError, TECTemp, PointsReturned, TECTemps, TECTimes, TECStates, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::WriteFPGASettingsToLocalFile ( _bstr_t filename, SAFEARRAY * * FPGASettings, unsigned long NumFPGASettings ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_WriteFPGASettingsToLocalFile(filename, FPGASettings, NumFPGASettings, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::ReadFPGASettingsFromLocalFile ( _bstr_t filename, SAFEARRAY * * FPGASettings, unsigned long * NumFPGASettings ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_ReadFPGASettingsFromLocalFile(filename, FPGASettings, NumFPGASettings, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::SendFPGASettingsToDevice ( SAFEARRAY * * FPGASettings, unsigned long NumFPGASettings ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_SendFPGASettingsToDevice(FPGASettings, NumFPGASettings, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetFPGASettingsFromDevice ( SAFEARRAY * * FPGASettings, unsigned long * NumFPGASettings ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetFPGASettingsFromDevice(FPGASettings, NumFPGASettings, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetFPGASettingNamesFromFile ( _bstr_t filename, SAFEARRAY * * FPGASettingNames, unsigned long * NumFPGASettings ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetFPGASettingNamesFromFile(filename, FPGASettingNames, NumFPGASettings, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetFPGASettingNamesFromDevice ( SAFEARRAY * * FPGASettingNames, unsigned long * NumFPGASettings ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetFPGASettingNamesFromDevice(FPGASettingNames, NumFPGASettings, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline unsigned long IAxsunOCTControl::GetLaserOnTime ( unsigned long * LaserOnTimeSeconds ) {
    unsigned long _result = 0;
    HRESULT _hr = raw_GetLaserOnTime(LaserOnTimeSeconds, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IAxsunOCTControl::StartPIMInterface ( ) {
    HRESULT _hr = raw_StartPIMInterface();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL IAxsunOCTControl::IsOCTDeviceConnected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsOCTDeviceConnected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IAxsunOCTControl::CheckIfOCTDevicePresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CheckIfOCTDevicePresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL IAxsunOCTControl::CheckIFPIMPresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CheckIFPIMPresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline HRESULT IAxsunOCTControl::CloseConnections ( ) {
    HRESULT _hr = raw_CloseConnections();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}
